/* autogenerated by Processing revision 1293 on 2024-04-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ColorCatcher extends PApplet {


int satelliteCount = 10;
// create an ArrayList<Satellite> to hold all the satellites
ArrayList<Satellite> satellites = new ArrayList<Satellite>();

boolean showSatellites = false;

// the central planet
Planet planet;

// start of sketch
public void setup() {

	// fill the entire screen
	/* size commented out by preprocessor */;
	// hi-res retina mode
	/* pixelDensity commented out by preprocessor */;
	
	// instatiate the planet
	String filename = "planet-001.svg";
	planet = new Planet(min(width, height) * 0.4f, filename);

	// instatiate the satellites
	for(int i=0; i<satelliteCount; i++) {
		satellites.add(new Satellite(i));
	}

	// start with blank background
	colorMode(RGB, 255, 255, 255, 255);
	background(210, 255);

}

// main loop
public void draw() {
	
	noCursor();

	float hue = map((millis()*0.1f) % 1000, 0, 1000, 0, 360);
	colorMode(RGB, 255, 255, 255, 255);
	noStroke();
	fill(255,50);
	rect(-1,-1,width+2,height+2);

	// draw the planet
	planet.draw();

	// draw all the satellites
	for (Satellite satellite : satellites) {
		satellite.move();
		satellite.draw();
	}
	
}


public void keyPressed() {

	if (key == ' ') {
		showSatellites = !showSatellites;
	}

	if (key >= '0' && key <= '9') {
		int index = key - '0';
		if (index < satellites.size()) {
			satellites.get(index).createRocket();
		}
	}

	if (key >= 'a' && key <= 'z') {
		int index = key - 'a';
		if (index < satellites.size()) {
			satellites.get(index).rocketAttack();
		}
	}

	if (key >= 'A' && key <= 'Z') {
		int index = key - 'A';
		if (index < satellites.size()) {
			satellites.get(index).repelRocket();
		}
	}

}
// The Planet class represents the central hexagonal shape in the middle of the screen

class Planet {

    float radius;
    PShape shape;

    Planet(float radius, String filename) {
        this.radius = radius;
        shape = loadShape(filename);
        shape.disableStyle();
    }

    // draw the planet
    public void draw() {

        strokeWeight(2);

        pushMatrix();
        translate(width*0.5f,height*0.5f);

        shapeMode(CENTER);
        colorMode(HSB, 360, 100, 100, 100);
        noFill();
        stroke(0, 0, 0, 100);
        strokeWeight(2);
        shape(shape, 0, 0, radius, radius);

        popMatrix();
    }

    // check if a point is inside the planet
    public boolean pixelInPoly(PVector[] verts, PVector pos) {

        int i, j;
        boolean c=false;
        int sides = verts.length;

        for (i=0,j=sides-1; i<sides; j=i++) {
            if (( ((verts[i].y <= pos.y) && (pos.y < verts[j].y)) || ((verts[j].y <= pos.y) && (pos.y < verts[i].y))) &&
            (pos.x < (verts[j].x - verts[i].x) * (pos.y - verts[i].y) / (verts[j].y - verts[i].y) + verts[i].x)) {
                c = !c;
            }
        }
        return c;
    }

    // // check if a point is inside the planet
    // String isInside(PVector pos) {
        
    //     for(int i=0; i<shape.getChildCount(); i++) {

    //         PShape child = shape.getChild(i);

    //         PVector[] verts = new PVector[child.getVertexCount()];
    //         for(int j=0; j<child.getVertexCount(); j++) {
    //             PVector vert = child.getVertex(j);
    //             verts[j] = new PVector(vert.x, vert.y);
    //         }

    //         if(pixelInPoly(verts, pos)) {
    //             return true;
    //         }
    //     }
    // }

}
// the Satellite class contains behavior of objects that are satellites spinning around the central planet
// rockets in the shape of color pencils follow the movements of the satellites

enum RocketState {
	Dead,
	Targetting,
	Hovering,
	Retreating,
	Attacking
};

class Satellite {

	int index = -1;
	float hue, saturation, brightness; // color
	float proximityDistance = 100;

	PVector satellitePosition, rocketPosition, rocketTarget;
	float satelliteAngle, rocketAngle;
	float radius, speed, rocketThrust, direction;
	float xCenter, yCenter;
	float randomOffset = 0;
	float wanderStrength = 0.25f;
	float wanderSpeed = 0.05f;

	RocketState rocketState = RocketState.Dead;

	Satellite(int index) {

		this.index = index;

		// to keep each Perlin noise value unique, we'll add a random offset to the index
		this.randomOffset = random(1000);

		satellitePosition = new PVector(0, 0);
		rocketPosition = new PVector(0, 0);

		// theindex determines the radius of the satellite around the central planet
		// given the planet's radius is 0.25 of min(width, height), the satellite's radius is 0.25 + the position of the satellite in the array
		// depending on the number of satellites, the range will be i/10 of the remaining space around the planet (approx 0.5 of min(width, height))
		float startRadius = 0.4f * min(width, height);
		float remainingRadius = 0.2f * min(width, height);
		this.radius = startRadius + (index * (remainingRadius / PApplet.parseFloat(satelliteCount)));

		this.satelliteAngle = random(360);
		this.speed = random(1.1f, 1.5f);
		this.direction = random(1) > 0.5f ? 1 : - 1;

		this.rocketThrust = this.speed * 1.5f;
	}


	public void createRocket() { // (hue, saturation, brightness)

		// calculate the radius from center screen to a corner
		float cornerRadius = sqrt(sq(width * 0.5f) + sq(height * 0.5f));

		// therocket position starts as a projection out from center of the planet to the edge of the screen
		// using the angle of the satellite, the rocket position is calculated as a point on the edge of the screen.
		// We'll start by placing the rocket at the center
		this.rocketPosition = calculateScreenEdgeTarget();

		// setthe angle of the rocket to the angle of the satellite
		this.rocketAngle = atan2(this.satellitePosition.y - this.rocketPosition.y, this.satellitePosition.x - this.rocketPosition.x);

		// seta random color (only 8 possible hues)
		hue = random(8) * 45;

		rocketState = RocketState.Targetting;

	}


	public PVector calculateScreenEdgeTarget() {
		
		// calculate the radius from center screen to a corner
		float cornerRadius = sqrt(sq(width * 0.5f) + sq(height * 0.5f));

		// therocket position starts as a projection out from center of the planet to the edge of the screen
		// using the angle of the satellite, the rocket position is calculated as a point on the edge of the screen.
		// We'll start by placing the rocket at the center
		PVector target = new PVector(width * 0.5f, height * 0.5f);
		// now project out to edge of screen
		target.x += (this.radius + (cornerRadius - this.radius)) * cos(radians(this.satelliteAngle));
		target.y += (this.radius + (cornerRadius - this.radius)) * sin(radians(this.satelliteAngle));

		return target;

	}


	public void repelRocket() {

		if (rocketState == RocketState.Dead) {
			println("Can't repel rocket #" + index + " in state " + rocketState);
			return;
		}

		rocketState = RocketState.Retreating;
		rocketTarget = calculateScreenEdgeTarget();

	}


	public void rocketAttack() {

		if (rocketState == RocketState.Dead || rocketState == RocketState.Targetting) {
			println("Can't attack with rocket #" + index + " in state " + rocketState);
			return;
		}

		rocketState = RocketState.Attacking;
		rocketTarget = new PVector(width * 0.5f, height * 0.5f);

	}


	public void move() {

		moveSatellite();
		moveRocket();
	}


	public void moveSatellite() {

		// get the distance of the rocket to this satellite
		float distance = dist(this.rocketPosition.x, this.rocketPosition.y, this.satellitePosition.x, this.satellitePosition.y);

		// if the rocket is hovering
		if ((rocketState == RocketState.Hovering || rocketState == RocketState.Targetting) && distance < proximityDistance) {
			// change state to Hovering if it isn't already
			rocketState = RocketState.Hovering;
			// increment angle
			this.satelliteAngle += this.speed * this.direction;
			// loop around 360 degrees
			this.satelliteAngle += 360;
			this.satelliteAngle %= 360;
		}

		// the satellite moves in a circle around the center of the screen
		this.satellitePosition.x = (width * 0.5f)  + this.radius * cos(radians(this.satelliteAngle));
		this.satellitePosition.y = (height * 0.5f) + this.radius * sin(radians(this.satelliteAngle));

	}


	public void moveRocket() {

		// start by targetting the center of the screen
		PVector targetPoint = new PVector(width*0.5f, height*0.5f);

		switch(rocketState) {
				
			case Dead:
				return;

			case Targetting:
			case Hovering:

				targetPoint.x = this.satellitePosition.x;
				targetPoint.y = this.satellitePosition.y;
				break;

			case Retreating:
				targetPoint.x = this.rocketTarget.x;
				targetPoint.y = this.rocketTarget.y;
				// if we've reached the target, the rocket is dead
				if (dist(targetPoint.x, targetPoint.y, this.rocketPosition.x, this.rocketPosition.y) < 20) {
					rocketState = RocketState.Dead;
				}
				break;

			case Attacking:
				targetPoint.x = this.rocketTarget.x;
				targetPoint.y = this.rocketTarget.y;
				float attackDistance = dist(targetPoint.x, targetPoint.y, this.rocketPosition.x, this.rocketPosition.y);
				// if we've reached the target, the rocket is dead
				if (attackDistance < 20) {
					rocketState = RocketState.Dead;
				}
				//println("Rocket #" + index + "\tcurrent position: " + this.rocketPosition + "\tattacking target at:" + targetPoint + "\tdistance:" + attackDistance);
				break;

		}

		// movetowards the target
		// calculatethe angle to the target
		float targetAngle = atan2(targetPoint.y - this.rocketPosition.y, targetPoint.x - this.rocketPosition.x);
		// calculatethe angle difference
		float angleDiff = targetAngle - this.rocketAngle;
		// makesurethe angle difference is between -PI and PI
		if (angleDiff >	PI) angleDiff -= TWO_PI;
		if (angleDiff < - PI) angleDiff += TWO_PI;

		switch(rocketState) {
			case Targetting:
				// add a little randomness to the targetting using perlin noise
				this.rocketAngle += map(noise(this.randomOffset + frameCount * wanderSpeed), 0, 1, -wanderStrength, wanderStrength);
				break;
			case Hovering:
				// add a little randomness to the targetting using perlin noise
				this.rocketAngle += map(noise(this.randomOffset + frameCount * wanderSpeed), 0, 1, -wanderStrength, wanderStrength);
				break;
		}
		
		// limitthe angle difference to the maximum turn rate
		angleDiff = constrain(angleDiff, -0.1f, 0.1f);
		// updatethe angle
		this.rocketAngle += angleDiff;
		// updatethe position
		this.rocketPosition.x += cos(this.rocketAngle) * this.rocketThrust;
		this.rocketPosition.y += sin(this.rocketAngle) * this.rocketThrust;

	}


	public void draw() {

		if (showSatellites) {
			drawSatellite();
		}
		drawRocket();
	}


	public void drawSatellite() {

		// thesatellite is drawn as a circle with a radius of 0.05 of min(width, height)
		float satelliteRadius = 20;
		stroke(0, 100, 0, 100);
		noFill();
		strokeWeight(1);
		circle(this.satellitePosition.x, this.satellitePosition.y, satelliteRadius);

	}


	public void drawRocket() {

		if (rocketState == RocketState.Dead) {
			return;
		}

		//draw the rocket
		pushMatrix();
		translate(this.rocketPosition.x, this.rocketPosition.y);
		rotate(this.rocketAngle);
		// setcolor
		colorMode(HSB, 360, 100, 100);
		noStroke();
		fill(hue, 100, 100);
		// draw shape
		beginShape();
		// itsort of is a cross between a rocket and a pencil
		float tip = 5;
		float body = 10;
		// start at tip
		vertex(5, 0);
		vertex(0, tip);
		vertex( -body, 5);
		vertex( -body, -5);
		vertex(0, -5);
		vertex(5, 0);
		// close the shape at the tip where we started
		endShape(CLOSE);
		popMatrix();

	}
}


  public void settings() { fullScreen();
pixelDensity(2); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ColorCatcher" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
