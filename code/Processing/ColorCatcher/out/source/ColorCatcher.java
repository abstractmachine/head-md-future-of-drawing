/* autogenerated by Processing revision 1293 on 2024-04-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ColorCatcher extends PApplet {


int satelliteCount = 10;
// create an ArrayList<Satellite> to hold all the satellites
ArrayList<Satellite> satellites = new ArrayList<Satellite>();

boolean showSatellites = true;

// the central planet
Planet planet;

// start of sketch
public void setup() {

	// fill the entire screen
	/* size commented out by preprocessor */;
	// hi-res retina mode
	/* pixelDensity commented out by preprocessor */;
	
	// instatiate the planet
	planet = new Planet(width*0.5f, height*0.5f, min(width, height) * 0.25f);

	// instatiate the satellites
	for(int i=0; i<satelliteCount; i++) {
		satellites.add(new Satellite(i));
	}

}

// main loop
public void draw() {
	
	float hue = map((millis()*0.1f) % 1000, 0, 1000, 0, 360);
	colorMode(HSB, 360, 100, 100);
	background(hue, 0, 100);

	// draw the planet
	planet.draw();

	// draw all the satellites
	for (Satellite satellite : satellites) {
		satellite.move();
		satellite.draw();
	}
	
}


public void keyPressed() {

	if (key == ' ') {
		showSatellites = !showSatellites;
	}

	if (key >= '0' && key <= '9') {
		int index = key - '0';
		satellites.get(index).createRocket();
	}

}
// The Planet class represents the central hexagonal shape in the middle of the screen

class Planet {

    float x, y, radius;

    Planet(float x, float y, float radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    // draw the planet
    public void draw() {

        colorMode(HSB, 360, 100, 100, 100);

        fill(0, 0, 100, 100);
        stroke(0, 0, 50, 100);
        strokeWeight(2);
        circle(x, y, radius * 2);
    }

}
// the Satellite class contains behavior of objects that are satellites spinning around the central planet
// rockets in the shape of color pencils follow the movements of the satellites

enum RocketState {
	Dead,
	Hover,
	Retreat,
	Attack
};

class Satellite {

	float hue, saturation, brightness; // color

	PVector satellitePosition, rocketPosition;
	float satelliteAngle, rocketAngle;
	float radius, speed, rocketThrust, direction;
	float xCenter, yCenter;

	RocketState rocketState = RocketState.Dead;

	Satellite(int index) {

		satellitePosition = new PVector(0, 0);
		rocketPosition = new PVector(0, 0);

		// theindex determines the radius of the satellite around the central planet
		// given the planet's radius is 0.25 of min(width, height), the satellite's radius is 0.25 + the position of the satellite in the array
		// depending on the number of satellites, the range will be i/10 of the remaining space around the planet (approx 0.5 of min(width, height))
		float startRadius = 0.4f * min(width, height);
		float remainingRadius = 0.25f * min(width, height);
		this.radius = startRadius + (index * (remainingRadius / 10.0f));

		this.satelliteAngle = random(360);
		this.speed = random(0.1f, 0.5f);
		this.direction = random(1) > 0.5f ? 1 : - 1;

		this.rocketThrust = this.speed * 7.5f;
	}


	public void createRocket() { // (hue, saturation, brightness)

		// calculate the radius from center screen to a corner
		float cornerRadius = sqrt(sq(width * 0.5f) + sq(height * 0.5f));

		// therocket position starts as a projection out from center of the planet to the edge of the screen
		// using the angle of the satellite, the rocket position is calculated as a point on the edge of the screen.
		// We'll start by placing the rocket at the center
		this.rocketPosition = new PVector(width * 0.5f, height * 0.5f);
		// nowproject out to edge of screen
		this.rocketPosition.x += (this.radius + (cornerRadius - this.radius)) * cos(radians(this.satelliteAngle));
		this.rocketPosition.y += (this.radius + (cornerRadius - this.radius)) * sin(radians(this.satelliteAngle));

		// setthe angle of the rocket to the angle of the satellite
		this.rocketAngle = atan2(this.satellitePosition.y - this.rocketPosition.y, this.satellitePosition.x - this.rocketPosition.x);

		// seta random color (only 8 possible hues)
		hue = random(8) * 45;

		rocketState = RocketState.Hover;

	}


	public void repelRocket() {
	}


	public void rocketAttack() {
	}


	public void move() {

		moveSatellite();
		moveRocket();
	}


	public void moveSatellite() {

		// get the distance of the rocket to this satellite
		float distance = dist(this.rocketPosition.x, this.rocketPosition.y, this.satellitePosition.x, this.satellitePosition.y);

		// if the rocket is hovering
		if (rocketState == RocketState.Hover && distance < 50) {
			// increment angle
			this.satelliteAngle += this.speed * this.direction;
			// loop around 360 degrees
			this.satelliteAngle += 360;
			this.satelliteAngle %= 360;
		}

		// the satellite moves in a circle around the center of the screen
		this.satellitePosition.x = (width * 0.5f)  + this.radius * cos(radians(this.satelliteAngle));
		this.satellitePosition.y = (height * 0.5f) + this.radius * sin(radians(this.satelliteAngle));

	}


	public void moveRocket() {

		switch(rocketState) {
				
			case Dead:
				// donothing
				break;

			case Hover:

				// movetowards the target
				// calculatethe angle to the target
				float targetAngle = atan2(this.satellitePosition.y - this.rocketPosition.y, this.satellitePosition.x - this.rocketPosition.x);
				// calculatethe angle difference
				float angleDiff = targetAngle - this.rocketAngle;
				// makesurethe angle difference is between -PI and PI
				if (angleDiff >	PI) angleDiff -= TWO_PI;
				if (angleDiff < - PI) angleDiff += TWO_PI;
				// limitthe angle difference to the maximum turn rate
				angleDiff = constrain(angleDiff, -0.1f, 0.1f);
				// updatethe angle
				this.rocketAngle += angleDiff;
				// updatethe position
				this.rocketPosition.x += cos(this.rocketAngle) * this.rocketThrust;
				this.rocketPosition.y += sin(this.rocketAngle) * this.rocketThrust;

				break;

			case Retreat:
				// donothing
				break;

			case Attack:
				break;

		}
	}


	public void draw() {

		if (showSatellites) {
			drawSatellite();
		}
		drawRocket();
	}


	public void drawSatellite() {

		// thesatellite is drawn as a circle with a radius of 0.05 of min(width, height)
		float satelliteRadius = 20;
		stroke(0, 100, 0, 100);
		noFill();
		strokeWeight(1);
		circle(this.satellitePosition.x, this.satellitePosition.y, satelliteRadius);

	}


	public void drawRocket() {

		//draw the rocket
		pushMatrix();
		translate(this.rocketPosition.x, this.rocketPosition.y);
		rotate(this.rocketAngle);
		// setcolor
		colorMode(HSB, 360, 100, 100);
		noStroke();
		fill(hue, 100, 100);
		// draw shape
		beginShape();
		// itsort of is a cross between a rocket and a pencil
		float tip = 5;
		float body = 10;
		// start at tip
		vertex(5, 0);
		vertex(0, tip);
		vertex( -body, 5);
		vertex( -body, -5);
		vertex(0, -5);
		vertex(5, 0);
		// close the shape at the tip where we started
		endShape(CLOSE);
		popMatrix();

	}
}


  public void settings() { fullScreen();
pixelDensity(2); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ColorCatcher" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
